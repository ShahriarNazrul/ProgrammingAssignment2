## This assignment is designed to create and stimulate cache of a matrix.

## It has two parts:

## Part_1. makeCacheMatrix - This function will create a special "matrix" object and cache its inverse

## Part_2. cacheSolve -  This function  will return an inverse of the 'matrix' object if it already exist in the cache and the object remain unchanged. Else, the function will calculate the inverse on the special 'matrix' returned by makeCacheMatrix.

## Part_1:
## This function will receive "matrix" object and cache the inverse of the matrix and store in the global environment

makeCacheMatrix <- function(x = matrix()) {
  ##Initialise the inverse matrix
  invMatrix <- NULL
  
  #Define the set function for the matrix
  set <- function(y) {
    x <<- y
    invMatrix <<- NULL
  }
  
  ##Define the return matrix object by defining it as get
  get <- function() {
    x ##Return special matrix
  }
  
  ##Setting the inverse matrix 
  setInvMatrix <- function(invM){
    invMatrix <<- invM ##Assign the inverse matrix to the environment var
  } 
  
  ##Define the function for returning the inverse matrix
  getInvMatrix <- function(){
    invMatrix ##The environment var inverse matrix is return
  }
  
  ##Put all defined function into a list for future call within the environment
  list(set = set,
       get = get,
       setInvMatrix = setInvMatrix,
       getInvMatrix = getInvMatrix)
}


## Part_2:
## 1. Check if the inverse object exist and the matrix is unchanged by getting the stored inverse matrix calling from makeCacheMatrix
## 2. Return the inverse object in cache if it satisfy the first rule.
## 3. Else, compute the inverse of the special 'matrix', store in makeCacheMatrix for future use and return the new inverse object.

cacheSolve <- function(x, ...) {
  ## 1. Get the available inverse of the original matrix generated by makeCacheMatrix
  invM <- x$getInvMatrix()
  
  ## 2. Verified if the inverse has already been calculated
  if (!is.null(invM)){
    
    ## Check if the return invMatrix is identical
    if ( identical( x$get() %*% invM, invM %*% x$get() ) ){
      
      ## Get it from the cache and skips the computation. 
      print("getting cached data")
      return(invM)
    }
  }
  
  ## 3. Else inverse matrix null or matrix change, calculates the inverse 
  data <- x$get()
  invM <- solve(data, ...)
  
  # Sets the value of the inverse in the cache via the setinv function.
  x$setInvMatrix(invM)
  
  ## Return a matrix that is the inverse of 'x'
  print("getting new computated data")
  return(invM)
}
